import ast
import os
import pandas as pd
from openpyxl import load_workbook, Workbook
from openpyxl.utils.dataframe import dataframe_to_rows

# Paths and Names
path = r'C:\Users\ishaansharma8\Desktop\cobol_modules_work'
output_excel_file_name = "test1"
input_excel_file_name = "input1"


# Code
df_in = pd.read_excel(path + "\\" + input_excel_file_name + ".xlsx")
files = [value for value in list(df_in["Module Names"]) if isinstance(value, str)]
call_chains = [ast.literal_eval(value) for value in list(df_in["Call Chains"]) if isinstance(value, str)]
copybook = [value for value in list(df_in["Copybook"]) if isinstance(value, str)]
print(files, call_chains, copybook)

call_statement = []
calls = []
call_descriptions = []
call_names = []
call_line_number = []
invoke = []
sql_stat_in_called = []
line_number_searched = []
call_para_condition = []


def get_variable_value_back_traced(para_name, variable, k):
    f = open(path + "\\" + files[k] + ".txt")
    out = ''
    value = ''
    lines = f.readlines()
    lines = [l.strip() for l in lines]
    lines = dict(enumerate(lines))

    for key, value in lines.items():
        sentence = value.strip()
        if para_name[:-1] in sentence and 'PERFORM' in sentence:
            ind = int(key) - 1
            while ind > 0:
                ind = ind - 1
                sent = lines[ind]
                if 'MOVE' in sent and 'TO' in sent and variable in sent:
                    str_list = []
                    for x in sent.split(' '):
                        if x:
                            str_list.append(x)
                    out = ' '.join(str_list)
                    out = out.split(' ')[1]
                    break

    num = 0
    if out:
        num = 1
    return out, num


def get_variable_from_copybook(variable):
    for file in copybook:
        f = '\\' + file + '.txt'
        f = open(path + f)
        out = ''
        value = ''
        lines = f.readlines()
        # lines = [l.strip() for l in lines]
        # lines = dict(enumerate(lines))

        statement_list = []
        statement_str = ''
        flag_read = 0
        for value in lines:
            sentence = value.strip()
            if variable in sentence:
                flag_read = 1
            if flag_read == 1:
                temp_list = sentence.split(' ')
                for x in temp_list:
                    if x:
                        statement_list.append(x)
            if '.' in sentence:
                flag_read = 0
        statement_str += ' '.join(statement_list)
        try:
            out = (statement_list[-1])
        except:
            pass

    num = 0
    if out:
        num = 1
    return out, num


def search_sql_statements(variable):
    f = open(path + "\\" + variable + ".txt")
    lines = f.readlines()
    lines = dict(enumerate(lines))

    exec_flag = 0
    exec_statements = []

    for key, value in lines.items():
        if exec_flag == 1:
            sentence = value.strip()
            if 'SELECT' in sentence or 'INSERT' in sentence or 'UPDATE' in sentence or 'DELETE' in sentence:
                exec_statements.append(sentence)
            if len(sentence.strip(' ')) > 1 or len(sentence.strip(' ')) == 0:
                exec_flag = 0
            else:
                exec_statements.append(sentence)
        if 'EXEC SQL' == value.strip():
            exec_flag = 1
        if 'END-EXEC.' == value.strip():
            exec_flag = 0

    return '\n'.join(exec_statements)


def sql_statement_find_based_on_condition(variable, module_name):
    called_module = open(path + "\\" + variable + ".txt")
    lines = called_module.readlines()
    line_dict = dict(enumerate(lines))
    # ind = call_names.index(module_name)
    ind = 0
    for p in range(0, len(call_names)):
        if module_name == call_names[p]:
            if call_line_number[p] not in line_number_searched:
                line_number_searched.append(call_line_number[p])
                ind = p
                break
            else:
                pass
    flag_cond_exec = 0
    flag_store_statement = 0

    list_of_invoke_cond = {}
    exec_statements = []
    for element in invoke[ind]:
        temp_list = []
        for x in element[:-1].split(' '):
            if x:
                temp_list.append(x)
        if 'MOVE ' in element:
            list_of_invoke_cond[temp_list[-1]] = temp_list[1]
        if 'SET ' in element:
            list_of_invoke_cond[temp_list[1]] = temp_list[-1]

    for p in range(0, len(line_dict) - 1):
        sentence = list(line_dict.values())[p].strip()
        next_sentence = list(line_dict.values())[p + 1].strip()

        if (('IF' in sentence and 'EXEC SQL' in next_sentence)
                or ('WHEN' in sentence and 'EXEC SQL' in next_sentence)):
            flag_cond_exec = 1
        if 'END-IF' == sentence or 'END-EVALUATE' == sentence:
            flag_cond_exec = 0

        if flag_cond_exec == 1 and flag_store_statement == 0:
            temp_list = sentence.split(' ')
            if len(temp_list) > 1:
                if temp_list[1] in list_of_invoke_cond.keys():
                    if list_of_invoke_cond[temp_list[1]] == temp_list[-1]:
                        flag_store_statement = 1
                        flag_cond_exec = 0

        if flag_store_statement == 1:
            for o in range(p + 1, len(line_dict) - 1):
                sql_stat = list(line_dict.values())[o].strip()
                exec_statements.append(sql_stat)
                if 'END-EXEC' in sql_stat:
                    break
            exec_statements.append('\n')
            flag_store_statement = 0
            flag_cond_exec = 0

    return '\n'.join(exec_statements)


def conditions_for_perform_para_of_call(dict_lines):
    for key in call_line_number:
        a = key

        while True:
            sentence = dict_lines[a]
            if sentence:
                if (len(sentence.split(' ')) == 1 and sentence[len(sentence) - 1] == '.'
                        and '*' not in sentence):
                    if sentence[:4].isnumeric():
                        break
            a -= 1
        perform_para_name = sentence[:-1]

        temp_list = []
        for ind, value in dict_lines.items():
            if perform_para_name in value.strip() and 'PERFORM' in value.strip() and '*' not in value.strip():
                # print(perform_para_name)
                lower_bound = ind
                index = ind - 1
                ignore_index = []
                stop_read = 0
                while stop_read == 0:
                    value = dict_lines[index]
                    if '*' not in value:
                        index -= 1
                        # print(value, stop_read)
                    elif '*' in value:
                        ignore_index.append(index)
                        index -= 1
                    if value.strip() == '':
                        for l1 in range(index + 1, lower_bound):
                            if l1 not in ignore_index:
                                sent = dict_lines[l1]
                                str_list = []
                                for x in sent.split(' '):
                                    if x:
                                        str_list.append(x)
                                sent = ' '.join(str_list)
                                temp_list.append(sent)
                        if temp_list:
                            temp_list.append(dict_lines[lower_bound])
                            temp_list.append(dict_lines[lower_bound + 1])
                        stop_read = 1
                    # else:
                    #     index -= 1
        value = '\n'.join(temp_list)
        call_para_condition.append(value)


def find_invoking_conditions_per_call(dict_lines):
    # Invoking Conditions Checking
    for key in call_line_number:
        lower_bound = key
        index = key - 1
        ignore_index = []
        temp_list = []
        stop_read = 0
        while stop_read == 0:
            value = dict_lines[index]
            if 'MOVE ' in value or 'SET ' in value or 'IF ' in value or 'ELSE ' in value or 'END-IF ' in value:
                str_list = []
                index -= 1
            elif '*' in value or not value:
                ignore_index.append(index)
                index -= 1
            else:
                for l1 in range(index + 1, lower_bound):
                    if l1 not in ignore_index:
                        sent = dict_lines[l1]
                        str_list = []
                        for x in sent.split(' '):
                            if x:
                                str_list.append(x)
                        sent = ' '.join(str_list)
                        temp_list.append(sent)
                stop_read = 1
        invoke.append(temp_list)


def find_called_variable_values(dict_lines, j):
    # Find values of called variable
    for p in range(0, len(call_descriptions)):
        found_name = 0
        for x in invoke[p]:  # Search for module name in invoking condition statements
            if found_name == 0:
                if 'MOVE' in x:
                    if call_descriptions[p] in x.split(' ')[-1]:
                        call_names.append(x.split(' ')[1])
                        found_name = 1
                if 'SET' in x:
                    if call_descriptions[p] in x.split(' ')[1]:
                        call_names.append(x.split(' '[-1]))
                        found_name = 1
        if found_name == 0:  # Search for module name by back tracing paragraph name
            a = call_line_number[p]
            while True:
                sentence = dict_lines[a]
                if sentence:
                    if (len(sentence.split(' ')) == 1 and sentence[len(sentence) - 1] == '.'
                            and '*' not in sentence):
                        if sentence[:4].isnumeric():
                            break
                a -= 1
            value, found_name = get_variable_value_back_traced(sentence, call_descriptions[p], j)
            if value:
                call_names.append(value)
        if found_name == 0:  # Search for module name by going through copybook
            value, found_name = get_variable_from_copybook(call_descriptions[p])
            if value:
                call_names.append(value[:-1])
        # if found_name == 0:
        #     module_name = files[j][1:-4]
        #     linked_variable_back_trace(module_name)
        if found_name == 0:
            print("failed")


def linked_variable_back_trace(workbook, sheet_name):
    for row in workbook[sheet_name].rows:
        # print(sheet_name, row)
        if row[4].value[0] != "'" and row[4].value[-1] != "'" and ' ' not in row[4].value.strip():

            new_ws = load_workbook(path + "\\" + output_excel_file_name + ".xlsx")

            for sheet2 in new_ws.sheetnames:
                for new_rows in new_ws[sheet2].rows:
                    if new_rows[4].value == "'" + row[0].value + "'":
                        row[4].value = f"  Check {new_rows[5]} for more info."


def get_previous_module_action_code(call_chain_list):
    workbook = load_workbook(path + "\\" + output_excel_file_name + ".xlsx")
    previous_code = ''
    for ind in range(0, len(call_chain_list)):
        if ind == 0 or ind == len(call_chain_list) - 1:
            pass
        else:
            ws = workbook[call_chain_list[ind]]
            for row in ws.rows:
                next_module = row[4].value[1:-1]
                if row[0].value == call_chain_list[ind] and next_module == call_chain_list[ind + 1]:
                    # print(call_chain_list[ind], next_module)
                    ws2 = workbook[call_chain_list[ind - 1]]
                    for row2 in ws2.rows:
                        called_module = row2[4].value[1:-1]
                        if called_module == row[0].value:
                            invoking_cond = row2[5].value.split('\n')
                            for cond in invoking_cond:
                                if 'ACTION-CODE' in cond:
                                    new_cond = cond.split(' ')
                                    if 'MOVE ' in cond:
                                        row[7].value = new_cond[1][1:-1]
                                    elif 'SET' in cond:
                                        row[7].value = new_cond[-1][1:-1]
                                    previous_code = row[7].value
                            if previous_code:
                                row[1].value = str(call_chain_list)
                                row2[1].value = str(call_chain_list)
                                if_cond = row[6].value.split('\n')
                                temp_if_cond = []
                                for cond in if_cond:
                                    if cond:
                                        temp_if_cond.append(cond)
                                # print(temp_if_cond)
                                try:
                                    cond = temp_if_cond[0].split('=')[1]
                                    if previous_code in cond:
                                        if ind > 1:
                                            if row2[8].value == "Called":
                                                row[8].value = "Called"
                                        elif ind == 1:
                                            row[8].value = "Called"
                                    else:
                                        row[8].value = "Not Called"
                                except:
                                    pass

    workbook.save(path + "\\" + output_excel_file_name + ".xlsx")


def find_call_statements(j):
    global calls, call_descriptions, call_names, call_line_number, invoke, sql_stat_in_called, \
        call_statement, call_para_condition

    f = '\\' + files[j] + '.txt'
    f = open(path + f)

    call_statement = []
    calls = []
    call_descriptions = []
    call_names = []
    call_line_number = []
    invoke = []
    sql_stat_in_called = []
    call_para_condition = []

    call_flag = 0
    lines = f.readlines()
    lines = [t.strip() for t in lines]
    enum_lines = dict(enumerate(lines))
    temp_call_list = []

    # Identify call statements in list
    for key, value in enum_lines.items():
        sentence = value.strip()
        if call_flag == 1 and len(sentence.split(' ')) <= 2:
            temp_call_list.append(sentence)
            # call_line_number.append(key)
        if '.' in sentence and call_flag == 1:
            call_flag = 0
            call_statement.append(temp_call_list)
            temp_call_list = []
        if 'CALL' in sentence.split(' ') and '*' not in sentence and call_flag == 0 and 'CALL ' in sentence:
            call_flag = 1
            temp_call_list.append(sentence)
            call_line_number.append(key)
            if '.' in sentence:
                call_flag = 0
                call_statement.append(temp_call_list)
                temp_call_list = []

    # Join call statements and store statements in list
    for x in call_statement:
        temp_str = ' '.join(x)
        calls.append(temp_str)

    # Find called variable name from statement
    t = 1
    for y in range(0, len(calls)):
        while True:
            called_mod = calls[y].split(' ')[t]
            if not called_mod:
                t += 1
            else:
                call_descriptions.append(called_mod)
                break

    # Find invoking conditions
    find_invoking_conditions_per_call(enum_lines)

    # Find called corresponding variable's module name
    find_called_variable_values(enum_lines, j)

    conditions_for_perform_para_of_call(enum_lines)

    # Check if called module exists in available module list, check for statements based on invoke conditions
    for d in call_names:
        sql = ''
        for f in files:
            mod_name = f
            # print(mod_name, d[1:-1])
            if mod_name == d[1:-1]:
                sql = sql_statement_find_based_on_condition(f, d)

        sql_stat_in_called.append(sql)

    # Create Dataframe

    df = pd.DataFrame(columns=['Calling Module', 'Call Chain', 'Called Module Variable', 'Call Statement',
                               'Called Module Passed Value', 'Invoking Conditions',
                               'Calling Statement paragraph running conditions',
                               'Previous Action Code Value',
                               'Call Statement/Paragraph status',
                               'Called Conditions',
                               'SQL statements in Called Module'])

    module_name = files[j]
    for b in range(0, len(calls)):
        mod_name = module_name
        call_chain_val = ''
        t = 1
        called_mod = call_descriptions[b]
        called_statement = ' '.join(call_statement[b])
        called_mod_name = call_names[b]
        invoking_cond = '\n'.join(invoke[b])
        if call_para_condition[b]:
            called_para_cond = call_para_condition[b]
        else:
            called_para_cond = ''
        previous_action_code = ''
        called_cond = ' '
        call_para_status = ' '
        sql_statements_called = sql_stat_in_called[b]
        df.loc[len(df)] = [mod_name, call_chain_val, called_mod, called_statement, called_mod_name,
                           invoking_cond, called_para_cond, previous_action_code, call_para_status, called_cond,
                           sql_statements_called]

    # Storage code

    excel_path = path + "\\" + output_excel_file_name + ".xlsx"
    wb2 = load_workbook(excel_path)
    if module_name in wb2.sheetnames:
        ws = wb2[module_name]
        for row in ws.iter_rows():
            for cell in row:
                cell.value = None
    else:
        sheet = wb2.create_sheet(module_name)
    wb2.save(filename=excel_path)

    wb3 = load_workbook(excel_path)
    sheet_active = wb3[module_name]
    for r in dataframe_to_rows(df, index=False, header=True):
        sheet_active.append(r)

    wb3.save(filename=excel_path)


if os.path.isfile(path + "\\" + output_excel_file_name + ".xlsx"):
    pass
else:
    wb = Workbook()
    wb.save(path + "\\" + output_excel_file_name + ".xlsx")

for i in range(0, len(files)):
    find_call_statements(i)

wb_check = load_workbook(path + "\\" + output_excel_file_name + ".xlsx")
for sheet in wb_check.sheetnames:
    linked_variable_back_trace(wb_check, sheet)
wb_check.save(path + "\\" + output_excel_file_name + ".xlsx")

for call_chain in call_chains:
    # print(call_chain)
    get_previous_module_action_code(call_chain)

wb = load_workbook(path + "\\" + output_excel_file_name + ".xlsx")
all_sheets = wb.sheetnames
for sheet in all_sheets:
    if wb[sheet].max_row <= 1 and wb[sheet].max_column <= 1:
        if not wb[sheet]['A1'].value:
            wb.remove(wb[sheet])
wb.save(path + "\\" + output_excel_file_name + ".xlsx")
